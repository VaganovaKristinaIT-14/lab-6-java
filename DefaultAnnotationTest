import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.lang.reflect.Field;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
/**
 * Тесты для аннотации @Default.
 */
class DefaultAnnotationTest {

  /**
   * Тест значения аннотации @Default на классе.
   */
  @Test
  void testDefaultAnnotationValueOnClass() {

    Default annotation = TestClassWithStringDefault.class.getAnnotation(Default.class);

    assertNotNull(annotation, "Аннотация @Default должна присутствовать на классе");

    assertEquals(String.class, annotation.value(),
        "Значение аннотации @Default должно быть String.class");
  }
  /**
   * Тест чтения аннотации через рефлексию.
   */
  @Test
  void testReflectionReturnsAnnotationOnClass() {
    Class<?> clazz = TestClassWithIntegerDefault.class;

    assertTrue(clazz.isAnnotationPresent(Default.class),
        "Класс должен иметь аннотацию @Default");

    Default annotation = clazz.getAnnotation(Default.class);
    assertNotNull(annotation, "Reflection должен возвращать аннотацию @Default");

    assertEquals(Integer.class, annotation.value(),
        "Аннотация должна возвращать Integer.class");
  }
  /**
   * Тест аннотации на поле через рефлексию.
   */
  @Test
  void testReflectionReturnsAnnotationOnField() throws NoSuchFieldException {

    Field field = TestClassWithStringDefault.class.getDeclaredField("fieldWithIntegerDefault");

    assertTrue(field.isAnnotationPresent(Default.class),
        "Поле должно иметь аннотацию @Default");


    Default annotation = field.getAnnotation(Default.class);
    assertNotNull(annotation, "Reflection должен возвращать аннотацию @Default с поля");


    assertEquals(Integer.class, annotation.value(),
        "Аннотация на поле должна возвращать Integer.class");
  }

  /**
   * Параметризованный тест для разных классов.
   */
  @ParameterizedTest
  @MethodSource("provideClassesForTesting")
  void testMultipleClassesWithDifferentDefaults(Class<?> testClass, Class<?> expectedDefaultClass) {

    assertTrue(testClass.isAnnotationPresent(Default.class),
        "Класс " + testClass.getSimpleName() + " должен иметь аннотацию @Default");


    Default annotation = testClass.getAnnotation(Default.class);
    assertNotNull(annotation, "Аннотация @Default не должна быть null");


    assertEquals(expectedDefaultClass, annotation.value(),
        "Класс " + testClass.getSimpleName() + " должен иметь Default(" + expectedDefaultClass.getSimpleName() + ".class)");
  }

  /**
   * Предоставляет данные для тестирования классов.
   */
  private static Stream<Arguments> provideClassesForTesting() {
    return Stream.of(
        Arguments.of(TestClassWithStringDefault.class, String.class),
        Arguments.of(TestClassWithIntegerDefault.class, Integer.class),
        Arguments.of(TestClassWithListDefault.class, java.util.List.class)
    );
  }
  /**
   * Параметризованный тест для полей с аннотациями.
   */
  @ParameterizedTest
  @MethodSource("provideFieldsForTesting")
  void testFieldAnnotations(Class<?> testClass, String fieldName, Class<?> expectedDefaultClass)
      throws NoSuchFieldException {

    Field field = testClass.getDeclaredField(fieldName);


    assertTrue(field.isAnnotationPresent(Default.class),
        "Поле " + fieldName + " должно иметь аннотацию @Default");

    Default annotation = field.getAnnotation(Default.class);


    assertEquals(expectedDefaultClass, annotation.value(),
        "Поле " + fieldName + " должно иметь Default(" + expectedDefaultClass.getSimpleName() + ".class)");
  }

  /**
   * Предоставляет данные для тестирования полей.
   */
  private static Stream<Arguments> provideFieldsForTesting() {
    return Stream.of(
        Arguments.of(TestClassWithStringDefault.class, "fieldWithIntegerDefault", Integer.class),
        Arguments.of(TestClassWithListDefault.class, "fieldWithDoubleDefault", Double.class)
    );
  }
}
