# Лабораторная работа №6

## Задание 1.1

**Текст задания**

@Invoke. Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke. Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически.

**Описание**

Аннотация @Invoke может применяться только к методам и доступна во время выполнения. Она не имеет свойств. Класс TestForInvoke содержит два метода: justMethod без аннотации и annotatedMethod с аннотацией @Invoke. Обработчик реализован в классе AnnotationProcessor в методе processForInvoke. Данный метод принимает объект, проверяет его на null, затем получает класс объекта и все его методы. Для каждого метода проверяется наличие аннотации @Invoke. Если метод не имеет параметров, он становится доступным для вызова и вызывается с помощью method.invoke(obj). Если метод имеет параметры, выводится сообщение об ошибке. В случае исключения выводится сообщение с информацией об ошибке. Метод также подсчитывает количество вызванных методов и выводит сообщение, если ни один метод не был вызван.

**Тестирование**
<img width="392" height="88" alt="image" src="https://github.com/user-attachments/assets/56ca50ed-1d27-43ed-a9a8-51ae985838ca" />


## Задание 1.2

**Текст задания**

@Default. Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию. Напишите обработчик, который выводит имя указанного класса по умолчанию.

**Описание**

Аннотация @Default может применяться к типам и полям, доступна во время выполнения и имеет обязательное свойство value типа Class. Класс TestForDefault проаннотирован аннотацией @Default со значением String.class. Обработчик реализован в классе AnnotationProcessor в методе processForDefault. Метод принимает класс, проверяет его на null, затем проверяет наличие аннотации @Default. Если аннотация присутствует, извлекается ее значение и выводится имя класса по умолчанию. Если аннотация отсутствует, выводится соответствующее сообщение.

**Тестирование**
<img width="551" height="71" alt="image" src="https://github.com/user-attachments/assets/63daa23b-292d-46d4-8411-42c3bb06f091" />


## Задание 1.3

**Текст задания**

@ToString. Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valueс двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей -- c @ToString(Mode.NO). Создайте метод, который формирует строковое представление объекта, учитывая только те поля, где @ToString имеет значение YES.

**Описание**

Аннотация @ToString может применяться к типам и полям, доступна во время выполнения и имеет необязательное свойство value со значениями YES или NO, по умолчанию YES. Класс TestForToString проаннотирован аннотацией @ToString и содержит поля: name, age, password и user. Поле password аннотировано @ToString("NO"). Обработчик реализован в классе AnnotationProcessor в методе processForToString. Метод принимает объект, проверяет его на null, затем получает класс объекта и все его поля. Для каждого поля проверяется наличие аннотации @ToString. Если аннотация присутствует и ее значение равно NO, поле исключается из строкового представления. В противном случае поле включается. Значение поля получается с помощью field.get(obj). Формируется строка, содержащая имя класса и значения включенных полей в формате имени поля и его значения.

**Тестирование**
<img width="717" height="50" alt="image" src="https://github.com/user-attachments/assets/01e2998c-db47-4cbc-b9e9-002c91a4255e" />


## Задание 1.4

**Текст задания**

@Validate. Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проанистрируйте класс аннотацией @Validate, передав список типов для проверки. Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

**Описание**

Аннотация @Validate может применяться к типам и аннотациям, доступна во время выполнения и имеет обязательное свойство value типа Class[]. Класс TestForValidate проаннотирован аннотацией @Validate со значением {String.class, Integer.class, Double.class}. Обработчик реализован в классе AnnotationProcessor в методе processForValidate. Метод принимает класс, проверяет его на null, затем проверяет наличие аннотации @Validate. Если аннотация присутствует, извлекается массив классов и выводится список их простых имен. Если аннотация отсутствует, выводится соответствующее сообщение.

**Тестирование**
<img width="645" height="155" alt="image" src="https://github.com/user-attachments/assets/510083ed-2933-406c-9e89-8fafea62553c" />


## Задание 1.5

**Текст задания**

@Two. Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проанистрируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения. Реализуйте обработчик, который считывает и выводит значения этих свойств.

**Описание**

Аннотация @Two может применяться только к типам, доступна во время выполнения и имеет два обязательных свойства: first типа String и second типа int. Класс TestForTwo проаннотирован аннотацией @Two со значениями first = "Пример строки", second = 42. Обработчик реализован в классе AnnotationProcessor в методе processForTwo. Метод принимает класс, проверяет его на null, затем проверяет наличие аннотации @Two. Если аннотация присутствует, извлекаются значения свойств first и second и выводятся на экран. Если аннотация отсутствует, выводится соответствующее сообщение.

**Тестирование**
<img width="677" height="153" alt="image" src="https://github.com/user-attachments/assets/bc5621b2-331b-4058-8dc6-bb5a640b2d4e" />


## Задание 1.6

**Текст задания**

@Cache. Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проанистрируйте класс аннотацией @Cache, указав несколько кешируемых областей. Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что список пуст.

**Описание**

Аннотация @Cache может применяться только к типам, доступна во время выполнения и имеет необязательное свойство value типа String[], по умолчанию пустой массив. Класс TestForCache проаннотирован аннотацией @Cache со значением {"users", "products", "orders"}. Обработчик реализован в классе AnnotationProcessor в методе processForCache. Метод принимает класс, проверяет его на null, затем проверяет наличие аннотации @Cache. Если аннотация присутствует, извлекается массив строк. Если массив пуст, выводится сообщение об этом. Если массив не пуст, выводится список всех кешируемых областей. Если аннотация отсутствует, выводится соответствующее сообщение.

**Тестирование**
<img width="493" height="156" alt="image" src="https://github.com/user-attachments/assets/bb8d9e30-5ffc-4838-8006-ec42c7da33fe" />


## Задание 2.3

**Текст задания**

Разработайте тест, используя фреймворк [Unit, который проверяет корректность обработки аннотации @Default.
• Проверить, что значение свойства value совпадает с ожидаемым классом.
• Убедиться, что если аннотация установлена на класс или поле, то отражение (Reflection) корректно возвращает её экземпляр.
• Добавить параметризованный тест (@ParameterizedTest) для проверки нескольких классов с разными типами по умолчанию.

**Описание**

Тестирование корректности обработки аннотации @Default проводится с использованием JUnit 5. Для тестирования созданы три класса: TestClassWithStringDefault с аннотацией @Default(String.class), TestClassWithIntegerDefault с аннотацией @Default(Integer.class) и TestClassWithListDefault с аннотацией @Default(java.util.List.class). В тесте testDefaultAnnotationValueOnClass проверяется, что аннотация @Default присутствует на классе TestClassWithStringDefault и что ее значение value равно String.class. Для этого используется метод getAnnotation(Default.class) для получения экземпляра аннотации, затем assertion assertEquals проверяет соответствие значения ожидаемому классу. В тесте testReflectionReturnsAnnotationOnClass проверяется, что для класса TestClassWithIntegerDefault метод isAnnotationPresent(Default.class) возвращает true, подтверждая наличие аннотации, и что getAnnotation(Default.class) возвращает не-null объект аннотации с корректным значением Integer.class. Аналогично, в тесте testReflectionReturnsAnnotationOnField проверяется наличие аннотации @Default на поле fieldWithIntegerDefault класса TestClassWithStringDefault и корректность ее значения Integer.class с помощью получения Field объекта и вызова методов isAnnotationPresent и getAnnotation для поля. Параметризованный тест testMultipleClassesWithDifferentDefaults использует аннотацию @ParameterizedTest и @MethodSource("provideClassesForTesting"). Метод provideClassesForTesting возвращает Stream из Arguments, каждый из которых содержит пару: тестовый класс и ожидаемый класс по умолчанию. В теле теста для каждого набора параметров проверяется наличие аннотации @Default на классе и соответствие значения value аннотации ожидаемому классу. Дополнительный параметризованный тест testFieldAnnotations аналогично проверяет аннотации на полях различных классов, используя метод provideFieldsForTesting в качестве источника данных.

**Тестирование**
<img width="818" height="235" alt="image" src="https://github.com/user-attachments/assets/b673a87b-4086-4071-8818-4f567cddbb54" />


## Задание 2.5

**Текст задания**

Реализовать тест, используя фреймворк [Unit, для класса, использующего аннотацию @Cache.
• Проверить, что список кешируемых сущностей (value) корректно считывается.
• Реализовать мок-тест (с использованием Mockito или встроенных подстановок), имитирующий обращение к кешу.
• Проверить, что если массив пуст -- кеширование не производится.
• Добавить отдельный тест для случая, когда кеш содержит несколько именованных областей.

**Описание**

Для тестирования используются два класса: TestForCache с аннотацией @Cache({"users", "products", "orders"}) и EmptyCacheService с аннотацией @Cache (значение по умолчанию - пустой массив). В тесте testCacheAnnotationValueReading проверяется, что аннотация @Cache присутствует на классе TestForCache, и корректно считывается ее значение. С помощью getAnnotation(Cache.class) получается экземпляр аннотации, затем проверяется, что массив value имеет длину 3 и содержит ожидаемые строки "users", "products", "orders" с использованием assertArrayEquals. В тесте testMockCacheAccessWithBuiltInMocks реализован мок-тест с использованием встроенного класса SimpleCacheMock, который имитирует работу с кешем. SimpleCacheMock содержит внутреннюю Map storage для хранения данных по ключам, формируемым как конкатенация области и ключа. В тесте проверяется работа методов put, get и contains: данные помещаются в кеш для областей "users" и "products", затем извлекаются и проверяются на соответствие ожидаемым значениям с помощью assertEquals, а также проверяется наличие ключей в кеше с помощью assertTrue. В тесте testNoCachingForEmptyArray проверяется обработка аннотации @Cache с пустым массивом. Для класса EmptyCacheService получается аннотация @Cache, проверяется, что массив value имеет длину 0. Затем вызывается вспомогательный метод shouldCacheBeUsed, который проверяет, что для класса с пустым массивом в аннотации метод возвращает false, что означает, что кеширование не производится. В тесте testMultipleNamedCacheAreas отдельно проверяется случай с несколькими кешируемыми областями. Для класса TestForCache проверяется, что массив value аннотации содержит три области, и проверяется точное соответствие каждой строки в массиве ожидаемым значениям с помощью assertEquals для каждого элемента.

**Тестирование**
<img width="855" height="145" alt="image" src="https://github.com/user-attachments/assets/a301757b-9edd-4cb7-921b-37687b1790b5" />
