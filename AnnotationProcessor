import java.lang.reflect.Method;
import java.lang.reflect.Field;

/**
 * Обработчик аннотаций через рефлексию.
 */
public class AnnotationProcessor {

  /**
   * Вызывает методы с аннотацией @Invoke.
   *
   * @param obj объект для обработки
   */
  public static void processForInvoke(Object obj) {
    if (obj == null) {
      System.out.println("Ошибка: передан null объект");
      return;
    }

    Class<?> testClass = obj.getClass();
    Method[] methods = testClass.getDeclaredMethods();

    int invokedCount = 0;

    for (Method method : methods) {
      if (method.isAnnotationPresent(Invoke.class)) {
        try {
          if (method.getParameterCount() == 0) {
            method.setAccessible(true);
            method.invoke(obj);
            invokedCount++;
          } else {
            System.out.println(
                "Метод " + method.getName() + " имеет параметры и не может быть вызван");
          }
        } catch (Exception e) {
          System.out.println(
              "Ошибка при вызове метода " + method.getName() + ": " + e.getMessage());
        }
      }
    }

    if (invokedCount == 0) {
      System.out.println("Не найдено методов с аннотацией @Invoke для вызова");
    }
  }

  /**
   * Читает значение аннотации @Default.
   *
   * @param targetClass класс для анализа
   */
  public static void processForDefault(Class<?> targetClass) {
    if (targetClass == null) {
      System.out.println("Ошибка: передан null класс");
      return;
    }

    if (targetClass.isAnnotationPresent(Default.class)) {
      Default defaultAnnotation = targetClass.getAnnotation(Default.class);
      Class<?> defaultClass = defaultAnnotation.value();
      System.out.println("Имя указанного класса по умолчанию: " + defaultClass.getName());
    } else {
      System.out.println("Аннотация @Default не найдена на классе");
    }
  }

  /**
   * Генерирует строковое представление объекта.
   *
   * @param obj объект для преобразования
   * @return строковое представление
   */
  public static String processForToString(Object obj) {
    if (obj == null) {
      return "null";
    }

    Class<?> targetClass = obj.getClass();
    StringBuilder result = new StringBuilder();
    result.append(targetClass.getSimpleName()).append("{ ");

    Field[] fields = targetClass.getDeclaredFields();
    boolean firstField = true;

    for (Field field : fields) {
      try {
        field.setAccessible(true);
        boolean includeField = true;

        if (field.isAnnotationPresent(ToString.class)) {
          ToString toStringAnnotation = field.getAnnotation(ToString.class);
          String fieldValue = toStringAnnotation.value();
          includeField = "YES".equals(fieldValue);
        }

        if (includeField) {
          if (!firstField) {
            result.append(", ");
          }
          result.append(field.getName()).append(" : ").append(field.get(obj));
          firstField = false;
        }

      } catch (IllegalAccessException e) {
        System.out.println("Ошибка доступа к полю " + field.getName());
      }
    }

    result.append(" }");
    return result.toString();
  }

  /**
   * Выводит классы из аннотации @Validate.
   *
   * @param targetClass класс для анализа
   */
  public static void processForValidate(Class<?> targetClass) {
    if (targetClass == null) {
      System.out.println("Ошибка: передан null класс");
      return;
    }

    if (targetClass.isAnnotationPresent(Validate.class)) {
      Validate validateAnnotation = targetClass.getAnnotation(Validate.class);
      Class<?>[] validationClasses = validateAnnotation.value();

      System.out.println("Классы указанные в аннотации @Validate:");
      for (Class<?> validationClass : validationClasses) {
        System.out.println("- " + validationClass.getSimpleName());
      }
    } else {
      System.out.println("Аннотация @Validate не найдена на классе");
    }
  }

  /**
   * Читает значения свойств аннотации @Two.
   *
   * @param targetClass класс для анализа
   */
  public static void processForTwo(Class<?> targetClass) {
    if (targetClass == null) {
      System.out.println("Ошибка: передан null класс");
      return;
    }

    if (targetClass.isAnnotationPresent(Two.class)) {
      Two twoAnnotation = targetClass.getAnnotation(Two.class);
      String firstValue = twoAnnotation.first();
      int secondValue = twoAnnotation.second();

      System.out.println("Значения свойств аннотации @Two:");
      System.out.println("first: " + firstValue);
      System.out.println("second: " + secondValue);
    } else {
      System.out.println("Аннотация @Two не найдена на классе");
    }
  }

  /**
   * Обрабатывает кешируемые области из аннотации @Cache.
   *
   * @param targetClass класс для анализа
   */
  public static void processForCache(Class<?> targetClass) {
    if (targetClass == null) {
      System.out.println("Ошибка: передан null класс");
      return;
    }

    if (targetClass.isAnnotationPresent(Cache.class)) {
      Cache cacheAnnotation = targetClass.getAnnotation(Cache.class);
      String[] cacheAreas = cacheAnnotation.value();

      if (cacheAreas.length == 0) {
        System.out.println("Список кешируемых областей пуст");
      } else {
        System.out.println("Кешируемые области:");
        for (String area : cacheAreas) {
          System.out.println("- " + area);
        }
      }
    } else {
      System.out.println("Аннотация @Cache не найдена");
    }
  }


}
